---
title: Rescript sob o ponto de vista de um dev JS
date: "2021-04-27"
description: Algumas opini√µes sobre a linguagem Rescript.
languageKey: en
languageLink: /en/rescript-from-a-js-dev-point-of-view
socialImage: /blog/images/rescript-from-a-js-dev-point-of-view/image-1.png
---

Voc√™s sabem que eu gosto muito de estudar sobre novas linguagens, gosto de estudar sobre compiladores e mais. As duas √∫ltimas linguagens que venho estudando s√£o go (obrigado [Guilherme](https://github.com/guilhermehubner) por me influenciar a usar Go em um projeto paralelo que fazemos juntos, um dos melhores engenheiros que conhe√ßo üíú) e Rescript. Voc√™s tamb√©m sabem que ganho dinheiro como desenvolvedor Javascript/front-end e eu amo isso, mesmo com todos os problemas que temos em Javascript continua uma √≥tima linguagem, flex√≠vel e f√°cil para um iniciante usar e para um desenvolvedor avan√ßado continuar usando e gostando. A linguagem tamb√©m √© flex√≠vel o suficiente para rodar em qualquer lugar, Web, Desktop, Mobile, Hardware, voc√™ escolhe! A comunidade √© muito ativa, nesse momento provavelmente temos algumas centenas de libs novas no NPM dispon√≠vel.


Essa √© uma apresenta√ß√£o e um artigo juntos, apenas explicando alguns dos pontos que eu considerei importante para dizer: "quer saber? vale a pena aprender Rescript e usar no dia a dia.". Esse n√£o √© um artigo para dizer que eu odeio Typescript, simplesmente porque eu n√£o odeio typescript. Eu venho trabalhando com Typescript nos √∫ltimos dois anos e gosto muito, mas o fato de gostar n√£o me impede de ver que TS tem seus problemas e muito o que melhorar como qualquer outra linguagem no mundo.

No final, tudo que eu quero √© me sentir produtivo usando algo para resolver problemas, mas os problemas certos. Eu quero me sentir confort√°vel em refatorar uma grande quantidade de c√≥digo e se o compilador compilou com sucesso tudo vai estar certo, de verdade. Eu quero escrever mais e fazer menos porque eu sei que o compilador n√£o vai deixar algu√©m usar as fun√ß√µes escritas da maneira errada, uma melhor infer√™ncia. Eu quero que isso seja r√°pido, t√£o r√°pido que eu vou salvar o arquivo duas vezes s√≥ pra ter certeza que funcionou ao inv√©z de abrir uma nova aba do twitter, Rescript.

Essa foi a maior introdu√ß√£o que eu j√° fiz, o que mostra o qu√£o interessado eu estou. Daqui pra baixo vou falar sobre os pontos que me chamaram a aten√ß√£o sobre Rescript para come√ßar a aprender mais sobre a linguagem. N√£o significa que eu estou certo, apenas opin√µes.


<h2 class="subtitle--separator">Integra√ß√£o com JavaScript</h2>

Aqui vai uma ideia para voc√™: Javascript √© a linguagem da web! JavaScript est√£ em todos os lugares! Sempre aposte no JavaScript! Mesmo que voc√™ n√£o goste disso, √© a verdade. Ent√£o, um dos primeiros pontos que eu olhei foi o qu√£o f√°cil seria usar algum c√≥digo ou lib JavaScript sem precisar reescrever isso para Rescript.

E por qu√™? Porque eu n√£o quero parar de usar JavaScript. Se alguma Tec nova super legal como Xstate surgir ou uma nova API no Browser, eu quero ser capaz de usar no meu c√≥digo Rescript de alguma forma, mesmo se a linguagem n√£o tem suporte oficial para isso ainda. Isso precisa ser f√°cil e r√°pido de criar se precisar.

Vamos supor que eu queira usar Lodash, esperando por coment√°rios: "voc√™ n√£o precisar usar lodash, bla bla bla..." Eu aposto que Lodash j√° salvou sua vida muitas vezes e √© s√≥ um exemplo. Continuando, tudo que voc√™ precisaria fazer seria definir um arquivo de bindings muito similar com o que fariamos em Typescript, por exemplo:

N√≥s criamos um arquivo `Lodash.res`: 

```js
@module("lodash/chunk")
external chunk: (array<'a>, int) => array<array<'a>> = "default"
```
E ent√£o em algum outro arquivo, usariamos o m√≥dulo Lodash:

```js
let myArray = [1,2,3]
let chunks = Lodash.chunk(myArray, 2)
```
Voc√™ tamb√©m pode exportar muitas fun√ß√µes do mesmo m√≥dulo, voltando ao nosso arquivo `Lodash.res`:

```js
@module("lodash")
external chunk: (array<'a>, int) => array<array<'a>> = "chunk"

@module("lodash")
external difference: (array<'a>, array<'a>) => array<'a> = "difference"
```
E usar da mesma forma:

```js
let myArray = [1,2,3]
let chunks = Lodash.chunk(myArray, 2)
let difference = Lodash.difference(myArray, [2])
```

<h2>Output leg√≠vel</h2>

O c√≥digo gerado pelo compilador do Rescript √© leg√≠vel para humanos, limpo e m√≠nimo. O que faz o tamanho do nosso bundle ser bem similar como se fosse alguma pessoa escrevendo o Javascript. Veja o examplo do c√≥digo acima gerado pelo compilador:

```js
// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Lodash from "lodash";

var myArray = [
  1,
  2,
  3
];

var chunks = Lodash.chunk(myArray, 2);

var difference = Lodash.difference(myArray, [2]);

export {
  myArray ,
  chunks ,
  difference ,
  
}
/* chunks Not a pure module */
```

<h2>√â Rescript ou JavaScript?</h2>

Outro ponto importante √© sobre a syntax, que √© muito parecida com JavaScript. Rescript √© outra linguagem diferente do Typescript que √© feito baseado em JavaScript, ent√£o ter uma syntax parecida √© muito bom para aprender r√°pido e ser produtivo com a linguagem de forma r√°pida. Para prover esse ponto, vamos fazer um exerc√≠cio chamado: "√â Rescript ou JavaScript?"

**√â Rescript ou JavaScript?**

```js
let person = {
  "age": 5,
  "name": "Big ReScript"
}
```

`Rescript!`

**√â Rescript ou JavaScript?**

```js
let add = (a, b) => a + b
let addTwo = add(2)
let test = addTwo(10) // 12
```

`Rescript!` JS n√£o √© curried por default, mais sobre isso abaixo.

**√â Rescript ou JavaScript?**

```js
let myArray = ["hello", "world", "how are you"]

let firstItem = myArray[0] // "hello"
```

`Rescript!`

De fato, quase todos os exemplos funcionariam nos dois mundos. A diferen√ßa √© que com Rescript n√≥s teriamos a ajuda do compilar com uma infer√™ncia de tipos maravilhosa para nos ajudar a escrever um c√≥digo melhor e mais seguro, isso sem nem precisar escrever nenhum tipo at√© agora.

Claro que existem algumas diferen√ßas tanto de syntax como de como a linguagem funciona, mas s√£o t√£o pequenas que √© apenas saber que elas existem. Por exemplo, ifs:

```js
let showMenu = true;

if showMenu {
  displayMenu()
} else {
  Js.log("nothing here...")
}
```

N√≥s n√£o precisamos usar parenteses em Rescript.

<h2>Sem Imports</h2>

Diferente de JS, n√£o existe export e import em Rescript. O que acontece √© que em Rescript todos os arquivos s√£o um modulo e o nome do arquivo precisa ser √∫nico, mesmo arquivos dentro de pastas s√£o acessados de forma global no mesmo n√≠vel que qualquer outro arquivo. Voc√™ s√≥ precisa usar o NomeDoArquivo que precisa ser em CamelCase ponto o tipo/fun√ß√£o que voc√™ quer usar.

N√≥s tamb√©m podemos usar `open` e ao inv√©z de usar **NomeDoModule.AlgumaCoisa** todas as vezes, n√≥s fariamos:

```js
open Lodash

let myArray = [1,2,3]
let chunks = chunk(myArray, 2)
```

N√£o ter imports/exports e ter um sistema de m√≥dulos por arquivo, nos for√ßa a manter uma estrutura mais flat que tem grandes vantagens a longo prazo.

Trecho tirado da documenta√ß√£o do Rescript:

>  By default, every file's type declaration, binding and module is exported, aka publicly usable by another file. This also means those values, once compiled into JS, are immediately usable by your JS code.

<h2>Sistema de Tipos</h2>

Bom eu poderia escrever alguma coisa com as minhas palavras, mas o time do Rescript fez um trabalho t√£o bom no site da documenta√ß√£o que eu vou apenas colar aqui o trecho sobre tipos:

> Types are the highlight of ReScript! They are:
>
> Strong. A type can't change into another type. In JavaScript, your variable's type might change when the code runs (aka at runtime). E.g. a number variable might change into a string sometimes. This is an anti-feature; it makes the code much harder to understand when reading or debugging.
>
>  Static. ReScript types are erased after compilation and don't exist at runtime. Never worry about your types dragging down performance. You don't need type info during runtime; we report all the information (especially all the type errors) during compile time. Catch the bugs earlier!
>
>  Sound. This is our biggest differentiator versus many other typed languages that compile to JavaScript. Our type system is guaranteed to never be wrong. Most type systems make a guess at the type of a value and show you a type in your editor that's sometime incorrect. We don't do that. We believe that a type system that is sometime incorrect can end up being dangerous due to expectation mismatches.
>
>  Fast. Many developers underestimate how much of their project's build time goes into type checking. Our type checker is one of the fastest around.
>
>  Inferred. You don't have to write down the types! ReScript can deduce them from their values. Yes, it might seem magical that we can deduce all of your program's types, without incorrectness, without your manual annotation, and do so quickly. Welcome to ReScript =).

Vamos explorar um pouco mais essa ideia de infer√™ncia, que √© uma das partes mais legais do Rescript. Escreva menos e fa√ßa mais!

Vamos considerar a seguinte fun√ß√£o:

```js
let add = (a, b) => a + b
```

Veja o que o compilador diria se voc√™ tentasse usar essa fun√ß√£o passando duas strings ao inv√©z de numeros:

```js
We've found a bug for you!
  /Users/dielduarte/localhost/testing-rescript/src/ExternalLibs.res:3:5-8

  1 ‚îÇ let add = (a, b) => a + b
  2 ‚îÇ
  3 ‚îÇ add("11", "2")

  This has type: string
  Somewhere wanted: int

  You can convert string to int with Belt.Int.fromString.

FAILED: cannot make progress due to previous errors.
>>>> Finish compiling(exit: 1)
```

Isso √© como o compilador do TS deveria funcionar üòÖ com Rescript eu sinto que estou a todo momento programando com um colega do lado. O compilador me mostra o erro, porqu√™, e ainda como resolver o problema e repare novamente, n√≥s n√£o tivemos que escrever nenhum tipo at√© ent√£o.

Mas como isso √© poss√≠vel? Bom, em Rescript usando o sinal `+` s√≥ √© valido para numeros, ent√£o o compilador infere que por default a fun√ß√£o Add s√≥ funciona para numeros. If voc√™ quisesse concatenar strings, teria que usar `++`.


<h2>Variants</h2>

A maioria das estruturas de dados em linguagens de program√ß√£o s√£o sobre "isso e aquilo". Variants nos permite expressar "isso ou aquilo".

Varians no primeiro olhar, se parecem com Enum com superpoderes.

Um exemplo simples seria:

```js

type myResponse =
  | Yes
  | No
  | PrettyMuch

let areYouCrushingIt = Yes

```
Ol√° enums, meu velho amigo.

Mas agora vem os super poderes, uma variant pode conter argumentos separado por uma virgula. Exemplo:

```js
type account =
  | None
  | Instagram(string)
  | Facebook(string, int)
```

Ent√£o, para o mesmo tipo voc√™ poderia usar:

```js
let myAccount = Facebook("Josh", 26)
let friendAccount = Instagram("Jenny")
```

Variants tamb√©m podem receber um Record (objeto):

```js
type user =
  | Number(int)
  | Id({name: string, password: string})

let me = Id({name: "Joe", password: "123"})
```
`me` continua sendo do tipo user, mas uma variant diferente. Usar pattern matching + variants √© uma t√©cnica muito poderosa, e pode at√© evitar algumas issues de performance como voc√™ pode ver [aqui](https://rescript-lang.org/docs/manual/latest/variant#design-decisions) onde n√≥s conseguimos reduzir a complexidade do nosso programa de O(n) para O(1).


<h2>Pattern matching</h2>

Se variants s√£o enums com super poderes, pattern matching √© o switch com super poderes. Misturar os dois √© ü§Ø

N√≥s podemos usar pattern matching para testar varia√ß√µes de qualquer tipo de formas diferentes, o exemplo abaixo est√£ testando se temos um `Number(id)` ou um `Id({ name: Jow"" })` um Id com o nome exatamente igual a Joe ou qualquer `Id(options)`

```js

type user =
  | Number(int)
  | Id({name: string, password: string})

let me = Id({name: "Joe", password: "123"})

switch me {
| Number(id) => Js.log("Your id is => " ++ Js.Int.toString(id))
| Id({name: "Joe"}) => Js.log("Welcome Joe!")
| Id(option) => Js.log("Welcome =>" ++ option.name)
}
```
Pattern matching podem ser usados para testar qualquer tipo, listas, arrays, tuplas, variants e mais. E como se isso n√£o fosse o suficiente, pattern matching tamb√©m √© exaustivo. Isso significa que todas as vezes que voc√™ estiver testando uma variav√©l, o compilador te obriga a testar todos os padr√µes que aquela vari√°vel pode ter, e se por acaso voc√™ esquecer disso, o compilador te lembra. Vamos supor que eu esqueci de tratar a variant `Id` no exemplo acima, o compilador me mostraria o seguinte erro:

```js
Warning number 8
  /Users/dielduarte/localhost/test-rescript/src/ExternalLibs.res:7:1-9:1

  5 ‚îÇ let me = Id({name: "Joe", password: "123"})
  6 ‚îÇ
  7 ‚îÇ switch me {
  8 ‚îÇ | Number(id) => Js.log("Your id is => " ++ Js.Int.toString(id))
  9 ‚îÇ }

  You forgot to handle a possible case here, for example:
  Id _

>>>> Finish compiling 128 mseconds
```

<h2>Curried por default</h2>
Essa √© uma das curiosidades sobre Rescript que eu mais curti. Todas as fun√ß√µes em Rescript s√£o curried por default, isso significa que, n√≥s podemos usar partial application sempre que for necess√°rio escrevendo menos c√≥digo para isso.

Em Javascript, para criar o exemplo que usamos acima n√≥s precisariamos usar closures ou algum helper tipo [Lodash curry](https://lodash.com/docs/4.17.15#curry):

```js
let add = (a) => (b) => a + b //closure
let addTwo = add(2)
let test = addTwo(10) // 12
```

Em Rescript n√≥s escreveriamos a fun√ß√£o da mesma forma mas usuarimos de forma parcial:

```js
let add = (a, b) => a + b
let addTwo = add(2)
let test = addTwo(10) // 12
```

<h2>Labeled arguments</h2>

Em Javascript/Typescript n√≥s estamos acostumados a usar um objeto como argumento para saber quais os nomes dos argumentos quando usando a fun√ß√£o sem precisar ir para a defini√ß√£o da mesma e tamb√©m, para poder passar os argumentos em qualquer ordem, exemplo:

```js
function updateUser(userOptions) {
  ....
}

//using the function
updateUser({
  name: 'Diel',
  age: 26
})
```

Em Rescript tamb√©m √© poss√≠vel passar um objeto, MAS, existe algo chamado "labeled arguments" que √© basicamente nomear os argumentos com um `~` na frente, dessa forma todas as vezes que usar a fun√ß√£o poderiamos passar o nome do argumento em qualquer ordem, exemplo:

```js
let updateUser = (~name, ~age) => {
  ...
}

//usando a fn
updateUser(~age=26, ~name="Diel") // arqui voc√™ passar o argumento em qualquer ordem
```

Lembra que todas as fun√ß√µes s√£o curried por default? Com labeled arguments n√≥s podemos usar a fun√ß√£o de forma parcial passando os argumentos em qualquer ordem, exemplo:

```js
let add = (~a, ~b) => a + b
let addTwoToA = add(~b=2)
let test = addTwoToA(~a=10)
```

<h2>Rescript n√£o tem null nem undefined</h2>

Isso √© √≥timo! N√≥s n√£o precisamos nos preocupar com categoria inteira de bugs, de toda forma a ideia de ter um valor n√£o existente continua sendo muito √∫til e por isso Rescript em o Option.

Um Option pode ser repesentado por `Some(Value)` ou `None` variants, e todas as vezes que voc√™ utilizar uma vari√°vel do tipo Option, Rescript vai te for√ßar a tratar todas as varia√ß√µes de forma exaustiva.

Por exemplo, um avatar de usu√°rio √© bem poss√≠vel que seja inexistente em muitas aplica√ß√µes.

```js
let userAvatar = Some("url...")

switch userAvatar {
| None => Js.log("The user doesn't have an avatar, let's show initials")
| Some(url) => Js.log("The user's avatar is " ++ url)
}
```

E se voc√™ esquecer de tratar uma das variantes, o compilados vai te mostrar:

```js

Warning number 8
  /Users/dielduarte/localhost/testing-rescript/src/ExternalLibs.res:3:1-5:1

  1 ‚îÇ let userAvatar = Some("url...")
  2 ‚îÇ
  3 ‚îÇ switch userAvatar {
  4 ‚îÇ | Some(url) => Js.log("The user's avatar is " ++ url)
  5 ‚îÇ }

  You forgot to handle a possible case here, for example:
  None

>>>> Finish compiling 82 mseconds
```
üòç As vezes eu queria dar um beijo no compilador.

<h2>F√°cil de usar com qualquer ferramenta do ecosistema JS</h2>

Como Rescript compila para JS, voc√™ pode usar Rescript com qualquer ferramenta que funciona para JS, create-react-app, snowpack, Webpack, Babel, Rome, e mais...Qualquer coisa que funcione para JS vai funcionar em Rescript, porqu√™ a ideia √©:

Rescript compila para JS => e ent√£o qualquer ferramenta entende os arquivos JS gerados e simplesmente funciona! As ferramentas n√£o necessariamente precisam saber que voc√™ est√° usando Rescript. Para provar isso, eu criei esse template para usar Rescript com o Snowpack. Voc√™ pode acessar o c√≥digo aqui:

[dielduarte/react-snowpack-rescript-template](https://github.com/dielduarte/react-snowpack-rescript-template)

Voc√™ pode ver que para inicializar o server do snowpack, eu importei o arquivo index.bs.js gerado pelo Rescript dentro do index.html [here](https://github.com/dielduarte/react-snowpack-rescript-template/blob/main/index.html#L13)

<h2>Conclus√£o</h2>

Como eu disse no come√ßo do post, a ideia aqui foi falar sobre alguns pontos que eu achei interessante para come√ßar a estudar mais sobre Rescript. Ent√£o eu n√£o falei de muitas coisas sobre a linguagem e suas vantagens, mesmo assim, eu espero que esse artigo te ajude a ter mais interesse em aprender mais sobre Rescript.

E para voc√™, vale a pena estudar Rescript?