---
title: Modelando sua primeira aplica√ß√£o com Statecharts e Xstate
date: "2020-11-22"
description: Nesse e nos pr√≥ximos posts vamos contruir uma aplica√ß√£o utilizando Statecharts e a ajuda da lib Xstate...
languageKey: pt_br
languageLink: /en/modeling-your-first-application-using-statecharts-and-xstate
---


Nesse e nos pr√≥ximos posts vamos contruir uma aplica√ß√£o utilizando Statecharts e a ajuda da lib Xstate. Os posts ser√£o quebrados em 2 partes:

- O post que voc√™ est√° lendo ser√° como modelar sua aplica√ß√£o utilizando Statecharts e Xstate/Viz onde vamos cubrir alguns dos principais conceitos de Statecharts.
- Escrevendo sua aplica√ß√£o com React e Xstate

Sem mais delongas, bora pro post de hoje!

Antes de come√ßarmos a modelar uma aplica√ß√£o, precisamos entender um pouco mais sobre alguns dos conceitos de Statecharts, vale lembrar tamb√©m que todos os exemplos ser√£o usando Xstate mas voc√™ n√£o precisa de nenhuma lib para come√ßar usar hoje mesmo. Durante o desenvolvimento do modelo, vamos cobrir os seguintes conceitos:

- context
- state
- invoke
- actions
- guards

Uma das features mais legais do Xstate √© poder vizualizar seu c√≥digo, hoje vamos usar o xstate/viz que vai nos ajudar a criar nosso modelo. Antes de mais nada, abra o seguinte link: xstate/viz , voc√™ provavelmente ver√° uma p√°gina igual a da imagem abaixo, ele ir√° iniciar com uma fetch machine e com o c√≥digo do exemplo do lado direito.

![imagem mostrando o xstate/viz aberto com uma fetch machine.](/blog/images/modeling-your-first-application-using-statecharts-and-xstate/image-1.png)

A primeira coisa que vamos fazer √© atualizar o c√≥digo no Xstate/Viz para o c√≥digo abaixo e clicar em update:

```js
const catsApp = Machine({
    id: 'catsApp',
    initial: 'idle',
    states: {
      idle: {}
    }
  });
```

O c√≥digo acima √© o c√≥digo basico para iniciarmos uma nova State Machine, cada state machine recebe um id √∫nico, um estado inicial e claro, a lista de estados dispon√≠veis. O resultado ser√°:

![imagem mostrando o resultado do codigo colado no xstate/viz](/blog/images/modeling-your-first-application-using-statecharts-and-xstate/image-2.png)

A primeira coisa a se fazer √© pensar em quais estados nossa aplica√ß√£o pode ter, nesse exemplo vamos criar uma aplica√ß√£o que, ao clicar em um bot√£o busca de uma API uma imagem de um gatinho. A aplica√ß√£o tamb√©m tratar√° errors na api, habilitando o usu√°rio a tentar novamente por 3 vezes consecutivas caso a API retorne errors.

Com essa breve descri√ß√£o podemos ent√£o dizer que nossa aplica√ß√£o ter√° os seguintes estados:

- idle
- loading
- success
- error
- cant_retry

O resultado em c√≥digo ficaria assim:


```js
const catsApp = Machine({
    id: 'catsApp',
    initial: 'idle',
    states: {
      idle: {},
      loading: {},
      success: {},
      error: {},
      cant_retry: {}
    }
  });
```

E o resultado no xstate/viz:

![imagem mostrando o resultado do codigo colado no xstate/viz](/blog/images/modeling-your-first-application-using-statecharts-and-xstate/image-3.png)

N√£o se preocupe caso voc√™ esque√ßa de algum estado da primeira vez, aos poucos e com pr√°tica voc√™ vai pegando maldade e vai conseguir ser mais assertivo em quais estados sua aplica√ß√£o ou seu componente deve ter. Alterar caso precise √© mais simples do que parece, voc√™ pode usar o xstate/viz para te ajudar a vizualizar as mudan√ßas e testar todos os fluxos poss√≠veis.

Lembra do nosso diagrama de transi√ß√£o de estados falado no primeiro post dessa s√©rie, onde mostramos que come√ßando em um estado A ‚áí um vento X aconteceu ‚áí vamos para um estado B ? O pr√≥ximo passo √© definir quais eventos dentro do seu sistema for√ßa uma transi√ß√£o de estado. Exemplo, quando estamos no estado inicial (**idle)** podemos dizer que o evento **LOAD_NEW_PICTURE** for√ßa uma transi√ß√£o para o estado **loading** ou seja:

- **idle ‚áí LOAD_NEW_PICTURE ‚áí loading**
- **loading ‚áí ON_DONE ‚áí sucess**
- **loading ‚áí ON_ERROR ‚áí error**
- **success ‚áí LOAD_NEW_PICTURE ‚áí loading**
- **error ‚áí RETRY ‚áí loading**

Em c√≥digo ficaria:


```js
const catsApp = Machine({
    id: 'catsApp',
    initial: 'idle',
    states: {
      idle: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      loading: {
        on: {
          ON_DONE: 'success',
          ON_ERROR: 'error'  
        }
      },
      success: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      error: {
        on: {
          RETRY: 'loading'
        }
      },
      cant_retry: {}
    }
  });
```

e no xstate/viz:

![imagem mostrando o resultado do codigo colado no xstate/viz](/blog/images/modeling-your-first-application-using-statecharts-and-xstate/image-4.png)

Vizualizar seu c√≥digo √© muito interessante, no exemplo acima, podemos ver nitidamente qual evento leva a aplica√ß√£o para outro estado e todos os fluxos poss√≠veis. E inclusive furos no sistema, veja como o estado cant_retry nunca acontecer√° pois nenhum evento for√ßa uma transi√ß√£o at√© ele ü§∑‚Äç‚ôÇÔ∏è mas calma, n√≥s vamos chegar l√°.

### Context

Context √© uma feature da lib Xstate que ter permite salvar contextos din√¢micos dependendo do estado que sua aplica√ß√£o est√°. Context nesse caso √© o nosso famoso estado como estamos acostumados a usar com outras libs como Redux, Mobx, Context Api no caso de usar com React, ou at√© mesmo um simples componente state.

Nesse caso, nosso contexto ser√° a nossa foto atual para ser exibida e a quantidade de vezes que o usu√°rio tentou buscar uma nova foto em caso de erros, precisamos iniciar nossa machine com o contexto inicial, o c√≥digo ent√£o ficaria dessa forma:

```js
const catsApp = Machine({
    id: 'catsApp',
    initial: 'idle',
	  context: {
	    currentImageUrl: '',
      retryTimes: 0
    },
    states: {
      idle: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      loading: {
        on: {
          ON_DONE: 'success',
          ON_ERROR: 'error'  
        }
      },
      success: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      error: {
        on: {
          RETRY: 'loading'
        }
      },
      cant_retry: {}
    }
  });
```

Perceba que nesse caso, n√£o temos nenhuma altera√ß√£o nos estados da aplica√ß√£o. Mas no xstate/viz se voc√™ abrir a aba chamada `State` voc√™ pode ver que ele te mostra qual o estado atual da aplica√ß√£o e qual os valores do contexto naquele momento.

![imagem mostrando a aba state no xstate/viz](/blog/images/modeling-your-first-application-using-statecharts-and-xstate/image-5.png)

### Trabalhando com a√ß√µes ass√≠ncronas 

Em qualquer aplica√ß√£o sempre teremos a√ß√µes que s√£o ass√≠ncronas e os resultados dessas a√ß√µes podem ou n√£o resultar em uma transi√ß√£o de estado. Usando Xstate chamamos isso de Services, e chamar um servi√ßo √© t√£o f√°cil e declarativo quanto qualquer outro conceito.

No nosso exemplo, o servi√ßo ser√° uma promise que vai fazer o request para buscar uma nova foto. O resultado dessa promise, se com sucesso ou erro gerara transi√ß√µes de estados. Pensando em um fluxo de dados quando a aplica√ß√£o sai do estado de ocioso(idle) para loading √© nesse momento que devemos ent√£o fazer nosso request. Preste bem aten√ß√£o no estado de loading no proximo exemplo:


```js
const catsApp = Machine({
    id: 'catsApp',
    initial: 'idle',
	  context: {
	    currentImageUrl: undefined,
      retryTimes: 0
    },
    states: {
      idle: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      loading: {
        invoke: {
	        src: 'fetchNewPicture',
          onDone: 'success',
          onError: 'error'
        }
      },
      success: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      error: {
        on: {
          RETRY: 'loading'
        }
      },
      cant_retry: {}
    }
  }, {
   services: {
     fetchNewPicture: () => fetch('') 
   }
  });
```

Substitu√≠mos nossos eventos por uma key chamada **invoke,** que recebe nesse exemplo, 3 configura√ß√µes: 

- **src**:  √â uma fun√ß√£o que retorna uma promisse. No nosso c√≥digo estamos passando apenas o nome da fun√ß√£o que ser√° chamada  e como segundo par√¢metro da fun√ß√£o **Machine**, passamos um objeto com a key **services** que nada mais √© que outro objeto com todos os servi√ßos que podem ser chamados.

- **onDone**: Qual o pr√≥ximo estado vamos redirecionar nossa machine se tudo ocorrer bem.

- **onError**: Qual o pr√≥ximo estado vamos redirecionar nossa machine se algum erro acontecer.

Vale lembrar que um servi√ßo pode ser uma promisse, observables, callback ou outra machine.

A vizualiza√ß√£o do nosso c√≥digo ficaria assim:

![imagem mostrando o resultado do codigo colado no xstate/viz](/blog/images/modeling-your-first-application-using-statecharts-and-xstate/image-6.png)

Da pra perceber que o viz coloca invoke / nome do servi√ßo dentro da quadradinho que representa o estado atual e tamb√©m o nome do servi√ßo dentro de um par√™nteses nos eventos simbolizando que aquele evento est√° relacionado ao servi√ßo chamado.

### Actions

Actions s√£o fun√ß√µes do tipo fire-and-forget, ou seja, fun√ß√µes  que n√£o geram uma transi√ß√£o de estados. As actions por√©m, s√£o muito usadas para rodar qualquer tipo de side effect que podem atualizar nosso contexto.

No nosso exemplo, quando a promisse que busca uma nova foto retorna precisamos chamar uma action para atualizar o valor do nosso contexto currentImageUrl.

Qualquer transi√ß√£o de estado dentro do Xstate pode receber apenas uma string com o nome do novo estado ou um objeto de configura√ß√£o, onde passamos o target que representa o pr√≥ximo estado e outras configura√ß√µes como por exemplo, uma action. Nesse caso vamos alterar nosso invoke objeto para:

```js
invoke: {
  src: 'fetchNewPicture',
  onDone: {
    target: 'success',
    actions: ['setCurrentImageUrl']
  },
  onError: 'error'
}
```

Perceba que passamos apenas uma string que √© refer√™ncia para uma fun√ß√£o action, tamb√©m vamos passar a action no segundo parametro da fun√ß√£o Machine, dessa forma, eu acredito que fica mais simples de ler nossa machine. O c√≥digo final ficaria assim:


```js
const catsApp = Machine({
    id: 'catsApp',
    initial: 'idle',
	  context: {
	    currentImageUrl: undefined,
      retryTimes: 0
    },
    states: {
      idle: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      loading: {
        invoke: {
	        src: 'fetchNewPicture',
          onDone: {
				    target: 'success',
				    actions: ['setCurrentImageUrl']
				  },
          onError: 'error'
        }
      },
      success: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      error: {
        on: {
          RETRY: 'loading'
        }
      },
      cant_retry: {}
    }
  }, {
   services: {
     fetchNewPicture: () => fetch('')
   },
   actions: {
     setCurrentImageUrl: (context, event) => ({
       currentImageUrl: event.data.imageUrl
     })
   }
  });
```

Uma action recebe por par√¢metro, o contexto atual e um event, esse event nada mais √© do que o retorno do servi√ßo, como nosso servi√ßo nesse caso √© uma promisse, nosso event ser√° o retorno dela. Caso nosso servi√ßo fosse um callback por ex, esse event seria a chamada do callback com qualquer informa√ß√£o adicional que o servi√ßo queira passar para a action.

A vizualiza√ß√£o do c√≥digo ficaria assim:

![imagem mostrando o resultado do codigo colado no xstate/viz](/blog/images/modeling-your-first-application-using-statecharts-and-xstate/image-7.png)

Perceba que o Viz coloca uma lista de a√ß√µes que acontecem quando um evento √© disparado com do / nome da action bem abaixo da representa√ß√£o visual de um evento.

Seguindo nosso exemplo, sempre que a promisse retornar um erro e o usu√°rio envia o evento RETRY devemos incrementar o valor de retryTimes no nosso contexto,  tamb√©m devemos resetar esse valor caso a promisse retorne com sucesso. Nesse caso, vamos adiconar uma action quando chamamos o evento RETRY e outra quando a promisse retorna com sucesso:


```js

const catsApp = Machine({
    id: 'catsApp',
    initial: 'idle',
	  context: {
	    currentImageUrl: undefined,
      retryTimes: 0
    },
    states: {
      idle: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      loading: {
        invoke: {
	        src: 'fetchNewPicture',
          onDone: {
				    target: 'success',
				    actions: ['setCurrentImageUrl', 'resetRetryTimes']
				  },
          onError: 'error'
        }
      },
      success: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      error: {
        on: {
          RETRY: {
            target: 'loading'
            actions: ['incrementRetryTimes']
          }
        }
      },
      cant_retry: {}
    }
  }, {
   services: {
     fetchNewPicture: () => fetch('')
   },
   actions: {
     setCurrentImageUrl: (context, event) => ({
       currentImageUrl: event.data.imageUrl
     }),
     resetRetryTimes: () => ({ retryTimes: 0 }),
     incrementRetryTimes: (context) => ({
       retryTimes:  context.retryTimes + 1
     })
   }
  });
```

A vizualiza√ß√£o do c√≥digo ficaria assim:

![imagem mostrando o resultado do codigo colado no xstate/viz](/blog/images/modeling-your-first-application-using-statecharts-and-xstate/image-8.png)

Agora voc√™ j√° sabe reconhecer quando uma action √© chamada apenas olhando a vizualiza√ß√£o do c√≥digo üöÄ.

### Guards

Guards s√£o usados para garantir que uma transi√ß√£o de estado que depende de alguma regra de negocio seja feita com seguran√ßa, usando o nosso exemplo, quando a promisse que busca uma nova foto retorna um erro, o usu√°rio pode tentar buscar novamente por 3 vezes. Ao tentar 3 vezes e sem sucesso, o usu√°rio √© ent√£o redirecionado para um estado onde ele n√£o pode mais tentar buscar uma nova foto.

Para fazer isso acontecer iremos usar os guards, o jeito de configurar um guard √© bem simples, no nosso caso, o evento RETRY vai conter duas poss√≠veis branchs:

```js
  error: {
      on: {
        RETRY: [
        {
          target: 'loading',
          actions: ['incrementRetryTimes']
        }, 
        {
          target: 'cant_retry'
        }
       ]
      }
    }
```


Nesse caso nada acontece, pois ainda n√£o adicionamos o nosso guard, para adicionar um ou mais guards basta colocar uma key cond na branch que deve ser redirecionada apenas se o guard retornar true. As branchs s√£o sempre lidas por ordem que foram declaradas, ou seja, nesse caso vamos colocar nosso guard na primeira branch, caso o retorno do guard seja falso iremos ent√£o para a pr√≥xima op√ß√£o que vai ent√£o for√ßar uma transi√ß√£o de estado para o estado cant_retry,  nosso c√≥digo ficaria assim:

```js
  error: {
      on: {
        RETRY: [
        {
          target: 'loading',
          actions: ['incrementRetryTimes'],
          cond: 'canRetry'
        }, 
        {
          target: 'cant_retry'
        }
       ]
      }
    },
```

Novamente usamos a string para referenciar ao nome da fun√ß√£o guard que estar√° no segundo par√¢metro do m√©todo Machine, c√≥digo final ficaria assim:

```js
const catsApp = Machine({
    id: 'catsApp',
    initial: 'idle',
	  context: {
	    currentImageUrl: undefined,
      retryTimes: 0 
    },
    states: {
      idle: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      loading: {
        invoke: {
	        src: 'fetchNewPicture',
          onDone: {
				    target: 'success',
				    actions: ['setCurrentImageUrl', 'resetRetryTimes']
				  },
          onError: 'error'
        }
      },
      success: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      error: {
        on: {
         RETRY: [
	        {
	          target: 'loading',
	          actions: ['incrementRetryTimes'],
	          cond: 'canRetry'
	        }, 
	        {
	          target: 'cant_retry'
	        }
	       ]
        }
      },
      cant_retry: {}
    }
  }, {
   services: {
     fetchNewPicture: () => fetch('')
   },
   actions: {
     setCurrentImageUrl: (context, event) => ({
       currentImageUrl: event.data.imageUrl
     }),
     resetRetryTimes: () => ({ retryTimes: 0 }),
     incrementRetryTimes: (context) => ({
       retryTimes:  context.retryTimes + 1
     })
   },
   guards: {
     canRetry: (context) => context.retryTimes <= 3
   }
  });
```

![imagem mostrando o resultado do codigo colado no xstate/viz](/blog/images/modeling-your-first-application-using-statecharts-and-xstate/image-9.png)


Perceba que agora nosso estado cant_retry tem uma liga√ß√£o com o evento Retry, e n√≥s temos dois eventos Retry que representam por ordem as branchs que declaramos. Perceba tamb√©m que a primeira branch dentro do evento tem um array de guards e os nomes dessas condi√ß√µes, um guard fica verde em caso retorne true e vermelho em caso retorne false representando que aquele evento n√£o vai acontecer.

### Type final

Estados do tipo final, representam que aquela machine est√° terminada, ou seja, nenhum evento ou transi√ß√£o ir√° acontecer depois que a machine chegar a esse estado. No nosso exemplo, o estado cant_retry √© nosso estado final. Vale lembrar que uma machine n√£o necessariamente precisa ter um estado final.

```js
const catsApp = Machine({
    id: 'catsApp',
    initial: 'idle',
	  context: {
	    currentImageUrl: '',
      retryTimes: 0
    },
    states: {
      idle: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      loading: {
        invoke: {
	        src: 'fetchNewPicture',
          onDone: {
				    target: 'success',
				    actions: ['setCurrentImageUrl', 'resetRetryTimes']
				  },
          onError: 'error'
        }
      },
      success: {
        on: {
          LOAD_NEW_PICTURE: 'loading'
        }
      },
      error: {
        on: {
         RETRY: [
	        {
	          target: 'loading',
	          actions: ['incrementRetryTimes'],
	          cond: 'canRetry'
	        }, 
	        {
	          target: 'cant_retry'
	        }
	       ]
        }
      },
      cant_retry: {
        type: 'final'
      }
    }
  }, {
   services: {
     fetchNewPicture: () => fetch('')
   },
   actions: {
     setCurrentImageUrl: (context, event) => ({
       currentImageUrl: event.data.imageUrl
     }),
     resetRetryTimes: () => ({ retryTimes: 0 }),
     incrementRetryTimes: (context) => ({
       retryTimes:  context.retryTimes + 1
     })
   },
   guards: {
     canRetry: (context) => context.retryTimes <= 3
   }
  });
```

Bom modelar uma aplica√ß√£o parece divertido agora, principalmente sabendo que todo o c√≥digo que escrevemos nessa tarefa √© o mesmo c√≥digo que ser√° usado na aplica√ß√£o final. No pr√≥ximo post iremos de fato usar esse codigo e criar nossa aplica√ß√£o front-end usando react e xstate.

Te vejo l√°!
